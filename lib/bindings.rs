/* automatically generated by rust-bindgen 0.70.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const _EEPROM_TYPE_ID_24C01: _EEPROM_TYPE = 0;
pub const _EEPROM_TYPE_ID_24C02: _EEPROM_TYPE = 1;
pub const _EEPROM_TYPE_ID_24C04: _EEPROM_TYPE = 2;
pub const _EEPROM_TYPE_ID_24C08: _EEPROM_TYPE = 3;
pub const _EEPROM_TYPE_ID_24C16: _EEPROM_TYPE = 4;
pub const _EEPROM_TYPE_ID_24C32: _EEPROM_TYPE = 5;
pub const _EEPROM_TYPE_ID_24C64: _EEPROM_TYPE = 6;
pub const _EEPROM_TYPE_ID_24C128: _EEPROM_TYPE = 7;
pub const _EEPROM_TYPE_ID_24C256: _EEPROM_TYPE = 8;
pub const _EEPROM_TYPE_ID_24C512: _EEPROM_TYPE = 9;
pub const _EEPROM_TYPE_ID_24C1024: _EEPROM_TYPE = 10;
pub const _EEPROM_TYPE_ID_24C2048: _EEPROM_TYPE = 11;
pub const _EEPROM_TYPE_ID_24C4096: _EEPROM_TYPE = 12;
pub type _EEPROM_TYPE = ::std::os::raw::c_uint;
pub use self::_EEPROM_TYPE as EEPROM_TYPE;
pub const _CHIP_TYPE_CHIP_CH341: _CHIP_TYPE = 0;
pub const _CHIP_TYPE_CHIP_CH347: _CHIP_TYPE = 1;
pub type _CHIP_TYPE = ::std::os::raw::c_uint;
pub use self::_CHIP_TYPE as CHIP_TYPE;
pub const FUNCTYPE_TYPE_TTY: FUNCTYPE = 0;
pub const FUNCTYPE_TYPE_HID: FUNCTYPE = 1;
pub const FUNCTYPE_TYPE_VCP: FUNCTYPE = 2;
pub type FUNCTYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " CH34XOpenDevice - open device\n @pathname: device path in /dev directory\n\n The function return positive file descriptor if successful, others if fail."]
    pub fn CH34xOpenDevice(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34XCloseDevice - close device\n @fd: file descriptor of device\n\n The function return true if successful, false if fail."]
    pub fn CH34xCloseDevice(fd: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH34x_GetDriverVersion - get vendor driver version\n @fd: file descriptor of device\n @Drv_Version: pointer to version string\n\n The function return true if successful, false if fail."]
    pub fn CH34x_GetDriverVersion(
        fd: ::std::os::raw::c_int,
        Drv_Version: *mut ::std::os::raw::c_uchar,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34x_GetChipVersion - get chip version\n @fd: file descriptor of device\n @Version: pointer to version\n\n The function return true if successful, false if fail."]
    pub fn CH34x_GetChipVersion(
        fd: ::std::os::raw::c_int,
        Version: *mut ::std::os::raw::c_uchar,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34x_GetChipType - get chip type\n @fd: file descriptor of device\n @Version: pointer to type\n\n The function return true if successful, false if fail."]
    pub fn CH34x_GetChipType(
        fd: ::std::os::raw::c_int,
        ChipType: *mut ::std::os::raw::c_uchar,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34X_GetDeviceID - get device vid and pid\n @fd: file descriptor of device\n @id: pointer to store id which contains vid and pid\n\n The function return true if successful, false if fail."]
    pub fn CH34X_GetDeviceID(fd: ::std::os::raw::c_int, id: *mut u32) -> bool;
}
extern "C" {
    #[doc = " CH34xSetParaMode - set chip parrallel work mode\n @fd: file descriptor of device\n @Mode: work mode, 0/1->EPP mode, 2->MEM mode\n\n The function return true if successful, false if fail."]
    pub fn CH34xSetParaMode(fd: ::std::os::raw::c_int, Mode: u8) -> bool;
}
extern "C" {
    #[doc = " CH34xInitParallel - initial chip parrallel work mode\n @fd: file descriptor of device\n @Mode: work mode, 0/1->EPP mode, 2->MEM mode\n\n The function return true if successful, false if fail."]
    pub fn CH34xInitParallel(fd: ::std::os::raw::c_int, Mode: u8) -> bool;
}
extern "C" {
    #[doc = " CH34xEppRead - read data or addr in parrallel EPP mode\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: read length\n @PipeMode: 0->read pipe0 data, 1->read pipe1 addr\n\n The function return read 0 if successful, others if fail."]
    pub fn CH34xEppRead(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut u8,
        ioLength: u32,
        PipeMode: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppWrite - write data or addr in parrallel EPP mode\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: write length\n @PipeMode: 0->write pipe0 data, 1->write pipe1 addr\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppWrite(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut u8,
        ioLength: u32,
        PipeMode: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppWriteData - write data in parrallel EPP mode\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: write length\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppWriteData(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut u8,
        ioLength: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppReadData - read data in parrallel EPP mode\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: read length\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppReadData(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut u8,
        ioLength: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppWriteAddr - write addr in parrallel EPP mode\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: write length\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppWriteAddr(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut u8,
        ioLength: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppReadAddr - read addr in parrallel EPP mode\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: read length\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppReadAddr(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut u8,
        ioLength: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xEppSetAddr - set addr in parrallel EPP mode\n @fd: file descriptor of device\n @iAddr: addr data\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xEppSetAddr(fd: ::std::os::raw::c_int, iAddr: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xSetTimeout - set USB data read and write timeout\n @fd: file descriptor of device\n @iWriteTimeout: data download timeout in milliseconds\n @iReadTimeout: data upload timeout in milliseconds\n\n The function return true if successful, false if fail."]
    pub fn CH34xSetTimeout(
        fd: ::std::os::raw::c_int,
        iWriteTimeout: u32,
        iReadTimeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xInitMEM - initial chip in parrallel MEM mode\n @fd: file descriptor of device\n\n The function return true if successful, false if fail."]
    pub fn CH34xInitMEM(fd: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH34xMEMReadData - read data in parrallel MEM mode\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: read length\n @PipeMode: 0->read pipe0, 1->read pipe1\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xMEMReadData(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut u8,
        ioLength: u32,
        PipeMode: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xMEMWriteData - write data in parrallel MEM mode\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: write length\n @PipeMode: 0->write pipe0, 1->write pipe1\n\n The function return 0 if successful, others if fail."]
    pub fn CH34xMEMWriteData(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut u8,
        ioLength: u32,
        PipeMode: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH34xSetStream - configure spi/i2c interface in stream mode\n @fd: file descriptor of device\n @Mode: stream mode\n ->bit0~1: set I2C SCL rate\n \t\t\t   --> 00 :\tlow rate 20KHz\n \t\t\t   --> 01 : standard rate 100KHz\n \t\t\t   --> 10 : fast rate 400KHz\n \t\t\t   --> 11 : high rate 750KHz\n ->bit2: set spi mode\n \t\t\t   --> 0 : one in one out(D3: clk, D5: out, D7: in)\n \t\t\t   --> 1 : two in two out(D3 :clk, D4/D5: out, D6/D7 :in)\n ->bit7: set spi data mode\n \t\t\t   --> 0 : low bit first\n       \t   --> 1 : high bit first\n other bits must keep 0\n\n The function return true if successful, false if fail."]
    pub fn CH34xSetStream(fd: ::std::os::raw::c_int, Mode: u8) -> bool;
}
extern "C" {
    #[doc = " CH34xSetDelaymS - delay operation\n @fd: file descriptor of device\n @iDelay: delay time in millseconds\n\n The function return true if successful, false if fail."]
    pub fn CH34xSetDelaymS(fd: ::std::os::raw::c_int, iDelay: u32) -> bool;
}
extern "C" {
    #[doc = " CH34xReadData - read for spi/i2c operation\n @fd: file descriptor of device\n @oReadBuffer: pointer to read buffer\n @oReadLength: pointer to read length\n\n The function return true if successful, false if fail."]
    pub fn CH34xReadData(
        fd: ::std::os::raw::c_int,
        oReadBuffer: *mut ::std::os::raw::c_void,
        oReadLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xWriteData - write data for spi/i2c operation\n @fd: file descriptor of device\n @iWriteBuffer: pointer to write buffer\n @iWriteLength: pointer to write length\n\n The function return true if successful, false if fail."]
    pub fn CH34xWriteData(
        fd: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        iWriteLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xWriteRead - write data then read for spi/i2c operation\n @fd: file descriptor of device\n @iWriteLength: write length\n @iWriteBuffer: pointer to write buffer\n @iReadStep: per read length\n @iReadTimes: read times\n @oReadLength: pointer to read length\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xWriteRead(
        fd: ::std::os::raw::c_int,
        iWriteLength: u32,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        iReadStep: u32,
        iReadTimes: u32,
        oReadLength: *mut u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xSetOutput - set direction and output data of CH341\n @iEnbale: set direction and data enable\n \t\t\t   --> Bit16 High :\teffect on Bit15~8 of iSetDataOut\n \t\t\t   --> Bit17 High :\teffect on Bit15~8 of iSetDirOut\n \t\t\t   --> Bit18 High :\teffect on Bit7~0 of iSetDataOut\n \t\t\t   --> Bit19 High :\teffect on Bit7~0 of iSetDirOut\n\t\t\t   --> Bit20 High :\teffect on Bit23~16 of iSetDataOut\n @iSetDirOut: set io direction\n\t\t\t  -- > Bit High : Output\n\t\t\t  -- > Bit Low : Input\n @iSetDataOut: set io data\n \t\t\t Output:\n\t\t\t  -- > Bit High : High level\n\t\t\t  -- > Bit Low : Low level\n Note:\n Bit7~Bit0<==>D7-D0, Bit8<==>ERR#, Bit9<==>PEMP, Bit10<==>INT#\n Bit11<==>SLCT, Bit13<==>WAIT#, Bit14<==>DATAS#/READ#, Bit15<==>ADDRS#/ADDR/ALE\n\n The pins below can only be used in output mode:\n Bit16<==>RESET#, Bit17<==>WRITE#, Bit18<==>SCL, Bit29<==>SDA\n\n The function return true if successful, false if fail."]
    pub fn CH34xSetOutput(
        fd: ::std::os::raw::c_int,
        iEnable: u32,
        iSetDirOut: u32,
        iSetDataOut: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xSet_D5_D0 - set direction and output data of D5-D0 on CH341\n @fd: file descriptor of device\n @iSetDirOut: set io direction\n\t\t\t  -- > Bit High : Output\n\t\t\t  -- > Bit Low : Input\n @iSetDataOut: set io data\n \t\t\t Output:\n\t\t\t  -- > Bit High : High level\n\t\t\t  -- > Bit Low : Low level\n\n The function return true if successful, false if fail."]
    pub fn CH34xSet_D5_D0(fd: ::std::os::raw::c_int, iSetDirOut: u8, iSetDataOut: u8) -> bool;
}
extern "C" {
    #[doc = " CH34xStreamI2C - write/read i2c in stream mode\n @fd: file descriptor of device\n @iWriteLength: write length\n @iWriteBuffer: pointer to write buffer\n @iReadLength: read length\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xStreamI2C(
        fd: ::std::os::raw::c_int,
        iWriteLength: u32,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        iReadLength: u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xReadEEPROM - read data from eeprom\n @fd: file descriptor of device\n @iEepromID: eeprom type\n @iAddr: address of eeprom\n @iLength: read length\n @oBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xReadEEPROM(
        fd: ::std::os::raw::c_int,
        iEepromID: EEPROM_TYPE,
        iAddr: u32,
        iLength: u32,
        oBuffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xWriteEEPROM - write data to eeprom\n @fd: file descriptor of device\n @iEepromID: eeprom type\n @iAddr: address of eeprom\n @iLength: write length\n @iBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xWriteEEPROM(
        fd: ::std::os::raw::c_int,
        iEepromID: EEPROM_TYPE,
        iAddr: u32,
        iLength: u32,
        iBuffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xStreamSPIx - write/read spi in stream mode\n @fd: file descriptor of device\n @iChipSelect: cs enable\n @iLength: the length of data\n @ioBuffer: one in one out buffer\n @ioBuffer2: two in two out buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xStreamSPIx(
        fd: ::std::os::raw::c_int,
        iChipSelect: u32,
        iLength: u32,
        ioBuffer: *mut ::std::os::raw::c_void,
        ioBuffer2: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH34xStreamSPI4 - write/read spi in 4-line stream mode\n @fd: file descriptor of device\n @iChipSelect: cs enable\n @iLength: the length of data\n @ioBuffer: one in one out buffer\n\n The function return true if successful, false if fail."]
    pub fn CH34xStreamSPI4(
        fd: ::std::os::raw::c_int,
        iChipSelect: u32,
        iLength: u32,
        ioBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_CONFIG {
    pub iMode: u8,
    pub iClock: u8,
    pub iByteOrder: u8,
    pub iSpiWriteReadInterval: u16,
    pub iSpiOutDefaultData: u8,
    pub iChipSelect: u32,
    pub CS1Polarity: u8,
    pub CS2Polarity: u8,
    pub iIsAutoDeativeCS: u16,
    pub iActiveDelay: u16,
    pub iDelayDeactive: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _SPI_CONFIG"][::std::mem::size_of::<_SPI_CONFIG>() - 20usize];
    ["Alignment of _SPI_CONFIG"][::std::mem::align_of::<_SPI_CONFIG>() - 1usize];
    ["Offset of field: _SPI_CONFIG::iMode"][::std::mem::offset_of!(_SPI_CONFIG, iMode) - 0usize];
    ["Offset of field: _SPI_CONFIG::iClock"][::std::mem::offset_of!(_SPI_CONFIG, iClock) - 1usize];
    ["Offset of field: _SPI_CONFIG::iByteOrder"]
        [::std::mem::offset_of!(_SPI_CONFIG, iByteOrder) - 2usize];
    ["Offset of field: _SPI_CONFIG::iSpiWriteReadInterval"]
        [::std::mem::offset_of!(_SPI_CONFIG, iSpiWriteReadInterval) - 3usize];
    ["Offset of field: _SPI_CONFIG::iSpiOutDefaultData"]
        [::std::mem::offset_of!(_SPI_CONFIG, iSpiOutDefaultData) - 5usize];
    ["Offset of field: _SPI_CONFIG::iChipSelect"]
        [::std::mem::offset_of!(_SPI_CONFIG, iChipSelect) - 6usize];
    ["Offset of field: _SPI_CONFIG::CS1Polarity"]
        [::std::mem::offset_of!(_SPI_CONFIG, CS1Polarity) - 10usize];
    ["Offset of field: _SPI_CONFIG::CS2Polarity"]
        [::std::mem::offset_of!(_SPI_CONFIG, CS2Polarity) - 11usize];
    ["Offset of field: _SPI_CONFIG::iIsAutoDeativeCS"]
        [::std::mem::offset_of!(_SPI_CONFIG, iIsAutoDeativeCS) - 12usize];
    ["Offset of field: _SPI_CONFIG::iActiveDelay"]
        [::std::mem::offset_of!(_SPI_CONFIG, iActiveDelay) - 14usize];
    ["Offset of field: _SPI_CONFIG::iDelayDeactive"]
        [::std::mem::offset_of!(_SPI_CONFIG, iDelayDeactive) - 16usize];
};
pub type mSpiCfgS = _SPI_CONFIG;
pub type mPSpiCfgS = *mut _SPI_CONFIG;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_InitTypeDef {
    pub SPI_Direction: u16,
    pub SPI_Mode: u16,
    pub SPI_DataSize: u16,
    pub SPI_CPOL: u16,
    pub SPI_CPHA: u16,
    pub SPI_NSS: u16,
    pub SPI_BaudRatePrescaler: u16,
    pub SPI_FirstBit: u16,
    pub SPI_CRCPolynomial: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _SPI_InitTypeDef"][::std::mem::size_of::<_SPI_InitTypeDef>() - 18usize];
    ["Alignment of _SPI_InitTypeDef"][::std::mem::align_of::<_SPI_InitTypeDef>() - 1usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_Direction"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_Direction) - 0usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_Mode"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_Mode) - 2usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_DataSize"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_DataSize) - 4usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_CPOL"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_CPOL) - 6usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_CPHA"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_CPHA) - 8usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_NSS"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_NSS) - 10usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_BaudRatePrescaler"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_BaudRatePrescaler) - 12usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_FirstBit"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_FirstBit) - 14usize];
    ["Offset of field: _SPI_InitTypeDef::SPI_CRCPolynomial"]
        [::std::mem::offset_of!(_SPI_InitTypeDef, SPI_CRCPolynomial) - 16usize];
};
pub type SPI_InitTypeDef = _SPI_InitTypeDef;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _StreamUSBCFG {
    pub SPIInitCfg: SPI_InitTypeDef,
    pub SpiWriteReadInterval: u16,
    pub SpiOutDefaultData: u8,
    pub OtherCfg: u8,
    pub Reserved: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _StreamUSBCFG"][::std::mem::size_of::<_StreamUSBCFG>() - 26usize];
    ["Alignment of _StreamUSBCFG"][::std::mem::align_of::<_StreamUSBCFG>() - 1usize];
    ["Offset of field: _StreamUSBCFG::SPIInitCfg"]
        [::std::mem::offset_of!(_StreamUSBCFG, SPIInitCfg) - 0usize];
    ["Offset of field: _StreamUSBCFG::SpiWriteReadInterval"]
        [::std::mem::offset_of!(_StreamUSBCFG, SpiWriteReadInterval) - 18usize];
    ["Offset of field: _StreamUSBCFG::SpiOutDefaultData"]
        [::std::mem::offset_of!(_StreamUSBCFG, SpiOutDefaultData) - 20usize];
    ["Offset of field: _StreamUSBCFG::OtherCfg"]
        [::std::mem::offset_of!(_StreamUSBCFG, OtherCfg) - 21usize];
    ["Offset of field: _StreamUSBCFG::Reserved"]
        [::std::mem::offset_of!(_StreamUSBCFG, Reserved) - 22usize];
};
pub type StreamHwCfgS = _StreamUSBCFG;
pub type PStreamHwCfgS = *mut _StreamUSBCFG;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEV_INFOR {
    pub fd: ::std::os::raw::c_int,
    pub FuncType: FUNCTYPE,
    pub DeviceID: [::std::os::raw::c_char; 64usize],
    pub ChipMode: u8,
    pub BulkOutEndpMaxSize: u16,
    pub BulkInEndpMaxSize: u16,
    pub UsbSpeedType: u8,
    pub CH347IfNum: u8,
    pub ProductString: [::std::os::raw::c_char; 64usize],
    pub ManufacturerString: [::std::os::raw::c_char; 64usize],
    pub WriteTimeout: u32,
    pub ReadTimeout: u32,
    pub FirewareVer: u8,
    pub CmdDataMaxSize: u32,
    pub dllUserSpiCfg: mSpiCfgS,
    pub dllHwCfg: StreamHwCfgS,
    pub CMDPKT_DATA_MAX_BITS: ::std::os::raw::c_int,
    pub MaxBitsPerBulk: ::std::os::raw::c_int,
    pub MaxBytesPerBulk: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _DEV_INFOR"][::std::mem::size_of::<_DEV_INFOR>() - 278usize];
    ["Alignment of _DEV_INFOR"][::std::mem::align_of::<_DEV_INFOR>() - 1usize];
    ["Offset of field: _DEV_INFOR::fd"][::std::mem::offset_of!(_DEV_INFOR, fd) - 0usize];
    ["Offset of field: _DEV_INFOR::FuncType"]
        [::std::mem::offset_of!(_DEV_INFOR, FuncType) - 4usize];
    ["Offset of field: _DEV_INFOR::DeviceID"]
        [::std::mem::offset_of!(_DEV_INFOR, DeviceID) - 8usize];
    ["Offset of field: _DEV_INFOR::ChipMode"]
        [::std::mem::offset_of!(_DEV_INFOR, ChipMode) - 72usize];
    ["Offset of field: _DEV_INFOR::BulkOutEndpMaxSize"]
        [::std::mem::offset_of!(_DEV_INFOR, BulkOutEndpMaxSize) - 73usize];
    ["Offset of field: _DEV_INFOR::BulkInEndpMaxSize"]
        [::std::mem::offset_of!(_DEV_INFOR, BulkInEndpMaxSize) - 75usize];
    ["Offset of field: _DEV_INFOR::UsbSpeedType"]
        [::std::mem::offset_of!(_DEV_INFOR, UsbSpeedType) - 77usize];
    ["Offset of field: _DEV_INFOR::CH347IfNum"]
        [::std::mem::offset_of!(_DEV_INFOR, CH347IfNum) - 78usize];
    ["Offset of field: _DEV_INFOR::ProductString"]
        [::std::mem::offset_of!(_DEV_INFOR, ProductString) - 79usize];
    ["Offset of field: _DEV_INFOR::ManufacturerString"]
        [::std::mem::offset_of!(_DEV_INFOR, ManufacturerString) - 143usize];
    ["Offset of field: _DEV_INFOR::WriteTimeout"]
        [::std::mem::offset_of!(_DEV_INFOR, WriteTimeout) - 207usize];
    ["Offset of field: _DEV_INFOR::ReadTimeout"]
        [::std::mem::offset_of!(_DEV_INFOR, ReadTimeout) - 211usize];
    ["Offset of field: _DEV_INFOR::FirewareVer"]
        [::std::mem::offset_of!(_DEV_INFOR, FirewareVer) - 215usize];
    ["Offset of field: _DEV_INFOR::CmdDataMaxSize"]
        [::std::mem::offset_of!(_DEV_INFOR, CmdDataMaxSize) - 216usize];
    ["Offset of field: _DEV_INFOR::dllUserSpiCfg"]
        [::std::mem::offset_of!(_DEV_INFOR, dllUserSpiCfg) - 220usize];
    ["Offset of field: _DEV_INFOR::dllHwCfg"]
        [::std::mem::offset_of!(_DEV_INFOR, dllHwCfg) - 240usize];
    ["Offset of field: _DEV_INFOR::CMDPKT_DATA_MAX_BITS"]
        [::std::mem::offset_of!(_DEV_INFOR, CMDPKT_DATA_MAX_BITS) - 266usize];
    ["Offset of field: _DEV_INFOR::MaxBitsPerBulk"]
        [::std::mem::offset_of!(_DEV_INFOR, MaxBitsPerBulk) - 270usize];
    ["Offset of field: _DEV_INFOR::MaxBytesPerBulk"]
        [::std::mem::offset_of!(_DEV_INFOR, MaxBytesPerBulk) - 274usize];
};
pub type mDeviceInforS = _DEV_INFOR;
pub type mPDeviceInforS = *mut _DEV_INFOR;
extern "C" {
    #[doc = " CH347OpenDevice - open device\n @pathname: device path in /dev directory\n\n The function return positive file descriptor if successful, others if fail."]
    pub fn CH347OpenDevice(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH347CloseDevice - close device\n @fd: file descriptor of device\n\n The function return true if successful, false if fail."]
    pub fn CH347CloseDevice(fd: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH347ReadData - read data\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: pointer to read length\n\n The function return true if successful, false if fail."]
    pub fn CH347ReadData(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut ::std::os::raw::c_void,
        ioLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347WriteData - write data\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: pointer to write length\n\n The function return true if successful, false if fail."]
    pub fn CH347WriteData(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut ::std::os::raw::c_void,
        ioLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347WriteRead - write data then read\n @fd: file descriptor of device\n @iWriteLength: write length\n @iWriteBuffer: pointer to write buffer\n @iReadStep: per read length\n @iReadTimes: read times\n @oReadLength: pointer to read length\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347WriteRead(
        fd: ::std::os::raw::c_int,
        iWriteLength: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        iReadStep: ::std::os::raw::c_int,
        iReadTimes: ::std::os::raw::c_int,
        oReadLength: *mut u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347SetTimeout - set USB data read and write timeout\n @fd: file descriptor of device\n @iWriteTimeout: data download timeout in milliseconds\n @iReadTimeout: data upload timeout in milliseconds\n\n The function return true if successful, false if fail."]
    pub fn CH347SetTimeout(
        fd: ::std::os::raw::c_int,
        iWriteTimeout: u32,
        iReadTimeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_GetHwStreamCfg - get spi setting from hardware\n @fd: file descriptor of device\n @StreamCfg: pointer to SPI stream configuration\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_GetHwStreamCfg(fd: ::std::os::raw::c_int, StreamCfg: *mut StreamHwCfgS)
        -> bool;
}
extern "C" {
    #[doc = " CH347SPI_Init - SPI interface initialization\n @fd: file descriptor of device\n @SpiCfg: pointer to SPI configuration\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_Init(fd: ::std::os::raw::c_int, SpiCfg: *mut mSpiCfgS) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_GetCfg - get SPI configuration\n @fd: file descriptor of device\n @SpiCfg: pointer to SPI configuration\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_GetCfg(fd: ::std::os::raw::c_int, SpiCfg: *mut mSpiCfgS) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_SetChipSelect - SPI chip selection initialization\n @fd: file descriptor of device\n @iEnableSelect: low 8 bits: CS1, high 8 bits: CS2, byte value -> 1: set CS, 0: ignore CS setting\n @iChipSelect: low 8 bits: CS1, high 8 bits: CS2, CS output, byte value -> 1: set CS, 0: cancel CS\n @iIsAutoDeativeCS: low 16 bits: CS1, high 16 bits: CS2, automatically undo the CS after operation completed\n @iActiveDelay: low 16 bits: CS1, high 16 bits: CS2, delay time of read and write operation after setting CS, unit: us\n @iDelayDeactive: low 16 bits: CS1, high 16 bits: CS2,, delay time of read and write operation after canceling CS, unit: us\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_SetChipSelect(
        fd: ::std::os::raw::c_int,
        iEnableSelect: u16,
        iChipSelect: u16,
        iIsAutoDeativeCS: ::std::os::raw::c_int,
        iActiveDelay: ::std::os::raw::c_int,
        iDelayDeactive: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_ChangeCS - SPI CS setting, must call CH347SPI_Init first\n @fd: file descriptor of device\n @iStatus: 0: cancel CS, 1: set CS\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_ChangeCS(fd: ::std::os::raw::c_int, iStatus: u8) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_Write - write SPI data\n @fd: file descriptor of device\n @ignoreCS: ignore SPI chip select while true, else auto set CS\n @iChipSelect: SPI chip select, ignore while BIT7 is 0, valid while BIT7 is 1\n @iLength: length to write\n @iWriteStep: per write length\n @ioBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_Write(
        fd: ::std::os::raw::c_int,
        ignoreCS: bool,
        iChipSelect: ::std::os::raw::c_int,
        iLength: ::std::os::raw::c_int,
        iWriteStep: ::std::os::raw::c_int,
        ioBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_Read - read SPI data\n @fd: file descriptor of device\n @ignoreCS: ignore SPI chip select while true, else auto set CS\n @iChipSelect: SPI chip select, ignore while BIT7 is 0, valid while BIT7 is 1\n @iLength: length to write\n @oLength: pointer to read length\n @ioBuffer: pointer to buffer, store data to be written from MOSI, and return data to be read from MISO\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_Read(
        fd: ::std::os::raw::c_int,
        ignoreCS: bool,
        iChipSelect: ::std::os::raw::c_int,
        iLength: ::std::os::raw::c_int,
        oLength: *mut u32,
        ioBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347SPI_WriteRead - write then read SPI data\n @fd: file descriptor of device\n @ignoreCS: ignore SPI chip select while true, else auto set CS\n @iChipSelect: SPI chip select, ignore while BIT7 is 0, valid while BIT7 is 1\n @iLength: data length to xfer\n @ioBuffer: pointer to buffer, store data to be written from MOSI, and return data to be read from MISO\n\n The function return true if successful, false if fail."]
    pub fn CH347SPI_WriteRead(
        fd: ::std::os::raw::c_int,
        ignoreCS: bool,
        iChipSelect: ::std::os::raw::c_int,
        iLength: ::std::os::raw::c_int,
        ioBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_INIT - JTGA interface initialization, mode and speed setting\n @fd: file descriptor of device\n @iClockRate: communication speed, valid value is 0-5, the higher the value, the faster the speed\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_INIT(fd: ::std::os::raw::c_int, iClockRate: u8) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_GetCfg - get JTGA speed setting\n @fd: file descriptor of device\n @iClockRate: pointer to communication speed, valid value is 0-5, the higher the value, the faster the speed\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_GetCfg(fd: ::std::os::raw::c_int, ClockRate: *mut u8) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_WriteRead - bitband mode JTAG IR/DR data read and write which is applicable for a small amount of data. Exp: command operation, state machine switching and other control transmission. For batch data transmission, it is recommended to use CH347Jtag_ WriteRead_Fast\n Command packets are read and written in batches in 4096 bytes\n State machine: Run-Test -> Shift-IR/DR.. -> exit IR/DR -> Run-Test\n @fd: file descriptor of device\n @IsDR: true: DR data read and write, false: IR data read and write\n @iWriteBitLength: write length\n @iWriteBitBuffer: pointer to write buffer\n @iReadTimes: read times\n @oReadBitLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBitBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_WriteRead(
        fd: ::std::os::raw::c_int,
        IsDR: bool,
        iWriteBitLength: ::std::os::raw::c_int,
        iWriteBitBuffer: *mut ::std::os::raw::c_void,
        oReadBitLength: *mut u32,
        oReadBitBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_WriteRead_Fast - JTAG IR/DR data read and write in batches for multi-byte continuous operation. Exp: JTAG firmware download operation. Hardware has a 4K buffer, such as write then read, the length should not exceed 4096 bytes. The buffer size can be adjusted.\n State machine: Run-Test -> Shift-IR/DR.. -> exit IR/DR -> Run-Test\n @fd: file descriptor of device\n @IsDR: true: DR data read and write, false: IR data read and write\n @iWriteBitLength: write length\n @iWriteBitBuffer: pointer to write buffer\n @iReadTimes: read times\n @oReadBitLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBitBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_WriteRead_Fast(
        fd: ::std::os::raw::c_int,
        IsDR: bool,
        iWriteLength: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        oReadLength: *mut u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_SwitchTapState - switch JTAG state machine\n @fd: file descriptor of device\n @TapState: machine state\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_SwitchTapState(fd: ::std::os::raw::c_int, TapState: u8) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_ByteWriteDR - JTAG DR write in bytes which used for multi-byte continuous operation. Exp: JTAG firmware download operation.\n State machine: Run-Test -> Shift-DR.. -> exit DR -> Run-Test\n @fd: file descriptor of device\n @iWriteLength: write length\n @iWriteBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_ByteWriteDR(
        fd: ::std::os::raw::c_int,
        iWriteLength: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_ByteReadDR - JTAG DR read in bytes which used for multi-byte continuous operation.\n State machine: Run-Test -> Shift-DR.. -> exit DR -> Run-Test\n @fd: file descriptor of device\n @oReadLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_ByteReadDR(
        fd: ::std::os::raw::c_int,
        oReadLength: *mut u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_ByteWriteIR - JTAG IR write in bytes which used for multi-byte continuous operation.\n State machine: Run-Test -> Shift-IR.. -> exit IR -> Run-Test\n @fd: file descriptor of device\n @iWriteLength: pointer to write length\n @iWriteBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_ByteWriteIR(
        fd: ::std::os::raw::c_int,
        iWriteLength: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_ByteReadIR - JTAG IR read in bytes which used for multi-byte continuous operation.\n State machine: Run-Test -> Shift-IR.. -> exit IR -> Run-Test\n @fd: file descriptor of device\n @oReadLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_ByteReadIR(
        fd: ::std::os::raw::c_int,
        oReadLength: *mut u32,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_WriteRead - bitband mode JTAG DR data write which is applicable for a small amount of data. Exp: command operation, state machine switching and other control transmission. For batch data transmission, it is recommended to use USB20Jtag_ByeWriteDR\n State machine: Run-Test -> Shift-DR.. -> exit DR -> Run-Test\n @fd: file descriptor of device\n @iWriteBitLength: pointer to write length\n @iWriteBitBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_BitWriteDR(
        fd: ::std::os::raw::c_int,
        iWriteBitLength: ::std::os::raw::c_int,
        iWriteBitBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_BitWriteIR - bitband mode JTAG IR data write which is applicable for a small amount of data. Exp: command operation, state machine switching and other control transmission. For batch data transmission, it is recommended to use USB20Jtag_ByeWriteIR\n State machine: Run-Test -> Shift-IR.. -> exit IR -> Run-Test\n @fd: file descriptor of device\n @iWriteBitLength: pointer to write length\n @iWriteBitBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_BitWriteIR(
        fd: ::std::os::raw::c_int,
        iWriteBitLength: ::std::os::raw::c_int,
        iWriteBitBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_BitWriteIR - bitband mode JTAG IR data read which is applicable for a small amount of data. Exp: command operation, state machine switching and other control transmission. For batch data transmission, it is recommended to use USB20Jtag_ByteReadIR\n State machine: Run-Test -> Shift-IR.. -> exit IR -> Run-Test\n @fd: file descriptor of device\n @oReadBitLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBitBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_BitReadIR(
        fd: ::std::os::raw::c_int,
        oReadBitLength: *mut u32,
        oReadBitBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Jtag_BitReadDR - bitband mode JTAG DR data read which is applicable for a small amount of data. Exp: command operation, state machine switching and other control transmission. For batch data transmission, it is recommended to use USB20Jtag_ByteReadDR\n State machine: Run-Test -> Shift-DR.. -> exit DR -> Run-Test\n @fd: file descriptor of device\n @oReadBitLength: pointer to read length, returns the actual number of bytes read on success\n @oReadBitBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347Jtag_BitReadDR(
        fd: ::std::os::raw::c_int,
        oReadBitLength: *mut u32,
        oReadBitBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347GPIO_Get - get gpio status\n @fd: file descriptor of device\n @iDir: gpio direction bits, bits0-7 on gpio0-7, 1 on ouput, 0 on input\n @iData: gpio level bits, bits0-7 on gpio0-7, 1 on high, 0 on low\n\n The function return true if success, others if fail."]
    pub fn CH347GPIO_Get(fd: ::std::os::raw::c_int, iDir: *mut u8, iData: *mut u8) -> bool;
}
extern "C" {
    #[doc = " CH347GPIO_Set - gpio setting\n @fd: file descriptor of device\n @iEnable: gpio function enable bits, bits0-7 on gpio0-7, 1 on enable\n @iSetDirOut: gpio direction bits, bits0-7 on gpio0-7, 1 on ouput, 0 on input\n @iSetDataOut: gpio output bits, bits0-7 on gpio0-7, if gpio direction is output, 1 on high, 0 on low\n\n The function return true if success, others if fail."]
    pub fn CH347GPIO_Set(
        fd: ::std::os::raw::c_int,
        iEnable: u8,
        iSetDirOut: u8,
        iSetDataOut: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Uart_Open - open device\n @pathname: device path in /dev directory\n\n The function return positive file descriptor if successful, others if fail."]
    pub fn CH347Uart_Open(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CH347Uart_Close - close device\n @fd: file descriptor of device\n\n The function return true if successful, false if fail."]
    pub fn CH347Uart_Close(fd: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH347Uart_GetCfg - read uart setting\n @fd: file descriptor of device\n @BaudRate: pointer to uart baudrate\n @ByteSize: pointer to data bits\n                  --> 0 : 5 bits\n                  --> 1 : 6 bits\n                  --> 2 : 7 bits\n                  --> 3 : 8 bits\n                  --> 4 : 16 bits\n @Parity: pointer parity\n                  --> 0 : none\n                  --> 1 : odd\n                  --> 2 : even\n                  --> 3 : mark\n                  --> 4 : space\n @StopBits: pointer to stop bits\n                  --> 0 : 1 bit\n                  --> 1 : 1.5 bits\n                  --> 2 : 2 bits\n @ByteTimeout: pointer to receive timeout value, unit: 100us\n\n The function return true if successful, false if fail."]
    pub fn CH347Uart_GetCfg(
        fd: ::std::os::raw::c_int,
        BaudRate: *mut u32,
        ByteSize: *mut u8,
        Parity: *mut u8,
        StopBits: *mut u8,
        ByteTimeout: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Uart_Init - uart setting\n @fd: file descriptor of device\n @BaudRate: uart baudrate\n @ByteSize: data bits setting\n                  --> 0 : 5 bits\n                  --> 1 : 6 bits\n                  --> 2 : 7 bits\n                  --> 3 : 8 bits\n                  --> 4 : 16 bits\n @Parity: parity setting\n                  --> 0 : none\n                  --> 1 : odd\n                  --> 2 : even\n                  --> 3 : mark\n                  --> 4 : space\n @StopBits: stop bits setting\n                  --> 0 : 1 bit\n                  --> 1 : 1.5 bits\n                  --> 2 : 2 bits\n @ByteTimeout: receive timeout value, unit: 100us\n\n The function return true if successful, false if fail."]
    pub fn CH347Uart_Init(
        fd: ::std::os::raw::c_int,
        BaudRate: ::std::os::raw::c_int,
        ByteSize: u8,
        Parity: u8,
        StopBits: u8,
        ByteTimeout: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Uart_Read - read for uart operation\n @fd: file descriptor of device\n @oBuffer: pointer to read buffer\n @ioLength: pointer to read length\n\n The function return true if successful, false if fail."]
    pub fn CH347Uart_Read(
        fd: ::std::os::raw::c_int,
        oBuffer: *mut ::std::os::raw::c_void,
        ioLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347Uart_Write - write data for uart operation\n @fd: file descriptor of device\n @iBuffer: pointer to write buffer\n @ioLength: pointer to write length\n\n The function return true if successful, false if fail."]
    pub fn CH347Uart_Write(
        fd: ::std::os::raw::c_int,
        iBuffer: *mut ::std::os::raw::c_void,
        ioLength: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347I2C_Set - configure i2c interface in stream mode\n @fd: file descriptor of device\n @iMode: stream mode\n ->bit0~1: set I2C SCL rate\n \t\t\t   --> 00 :\tlow rate 20KHz\n \t\t\t   --> 01 : standard rate 100KHz\n \t\t\t   --> 10 : fast rate 400KHz\n \t\t\t   --> 11 : high rate 750KHz\n other bits must keep 0\n\n The function return true if successful, false if fail."]
    pub fn CH347I2C_Set(fd: ::std::os::raw::c_int, iMode: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH347I2C_SetDelaymS - delay operation\n @fd: file descriptor of device\n @iDelay: delay time in millseconds\n\n The function return true if successful, false if fail."]
    pub fn CH347I2C_SetDelaymS(fd: ::std::os::raw::c_int, iDelay: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " CH347StreamI2C - write/read i2c in stream mode\n @fd: file descriptor of device\n @iWriteLength: write length\n @iWriteBuffer: pointer to write buffer\n @iReadLength: read length\n @oReadBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347StreamI2C(
        fd: ::std::os::raw::c_int,
        iWriteLength: ::std::os::raw::c_int,
        iWriteBuffer: *mut ::std::os::raw::c_void,
        iReadLength: ::std::os::raw::c_int,
        oReadBuffer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347ReadEEPROM - read data from eeprom\n @fd: file descriptor of device\n @iEepromID: eeprom type\n @iAddr: address of eeprom\n @iLength: read length\n @oBuffer: pointer to read buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347ReadEEPROM(
        fd: ::std::os::raw::c_int,
        iEepromID: EEPROM_TYPE,
        iAddr: ::std::os::raw::c_int,
        iLength: ::std::os::raw::c_int,
        oBuffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " CH347WriteEEPROM - write data to eeprom\n @fd: file descriptor of device\n @iEepromID: eeprom type\n @iAddr: address of eeprom\n @iLength: write length\n @iBuffer: pointer to write buffer\n\n The function return true if successful, false if fail."]
    pub fn CH347WriteEEPROM(
        fd: ::std::os::raw::c_int,
        iEepromID: EEPROM_TYPE,
        iAddr: ::std::os::raw::c_int,
        iLength: ::std::os::raw::c_int,
        iBuffer: *mut u8,
    ) -> bool;
}
